<html lang="it">
  <head>
    <title>Architettura di Von Neumann</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <style>
      body {
        font-family: Arial, sans-serif;
        color: #222;
        margin: 20px;
        background-image: url("https://wallpapers.com/images/hd/white-hd-1920-x-1080-background-v6vs7rl1s612r2zd.jpg");
        background-size: cover;
        background-attachment: fixed;
      }
      .container {
        background: rgba(255,255,255,0.94);
        max-width: 940px;
        margin: 28px auto;
        padding: 22px;
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      }
      h1 { margin-top:0; color:#111; }
      h2 { color:#333; margin-bottom:8px; }
      p, li { line-height:1.6; color:#222; }
      .diagram { display:grid; grid-template-columns:1fr 1fr; gap:14px; margin:12px 0; }
      .box {
        background:#f7f7f7;
        padding:12px;
        border-radius:6px;
        border:1px solid #eee;
      }
      .note { font-size:0.95em; color:#444; }
      a { color:#0645ad; text-decoration:none; }
      a:hover { text-decoration:underline; }
      @media (max-width:640px){ .diagram { grid-template-columns:1fr; } }
    </style>
  </head>
  <body>
    
    <div class="container">

        <h1><center>Architettura Non Von Neumann</center></h1>

        <div class="box">
        <h2>Harvard</h2>
        <p class="note"><strong>Definizione:</strong> L'architettura Harvard è un modello di calcolatore in cui le memorie per le istruzioni (codice) e per i dati sono fisicamente separate e possono essere accessate indipendentemente. Questa separazione permette il fetch di istruzioni e l'accesso ai dati in parallelo, riducendo i colli di bottiglia della memoria e migliorando le prestazioni in applicazioni embedded e di elaborazione digitale dei segnali.</p>
</div>
        <p class="note"><strong>Caratteristiche:</strong>
        - Memoria istruzioni separata dalla memoria dati<br>
        - Possibilità di accessi paralleli (instruction fetch + data access)<br>
        - Spesso usata in microcontrollori, DSP e sistemi embedded</p>

        <p class="note"><strong>Vantaggi:</strong> minore latenza nei fetch, migliore throughput per workload deterministici.</p>

        <p class="note"><strong>Limiti:</strong> minore flessibilità nella modifica dinamica del codice e aumento della complessità hardware; molte implementazioni moderne adottano varianti (Harvard modificata) che consentono trasferimenti controllati tra le memorie.</p>

    </div>

  </body>
</html>